df_tc$pointid == 'Km_10015'
df_tc |> filter(pointid =='Km_10015')
df_tc |> filter(pointid =='Km_10015')$geometry
df_tc |> filter(pointid =='Km_10015') |> subset(geometry)
df_tc |> filter(pointid =='Km_10015')
overlapping_parcels |> mutate(geometry = map2(geom, pointid, ~ st_intersection(.x, df_tc |> filter(pointid == .y))))
overlapping_parcels
# 4) Split parcels in overlapping circles
overlapping_parcels <-
buffer_result_2 |>
st_as_sf() |>
group_by(REF_ID) |>
filter(n()>1)
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[overlapping_parcels$pointid[i], "geometry"]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
circle_geom <- df_tc[overlapping_parcels$pointid[i], "geom"]
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[overlapping_parcels$pointid[i], "geom"]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
View(df_tc)
circle_geom <- df_tc[overlapping_parcels$pointid[i], "geometry"]
circle_geom <- df_tc[overlapping_parcels$pointid[i]]$geometry
circle_geom <- df_tc[overlapping_parcels$pointid[i]]
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i]]
for (i in 1:nrow(overlapping_parcels)) {}
for (i in 1:nrow(overlapping_parcels)) {print(overlapping_parcels$pointid[i])}
for (i in 1:nrow(overlapping_parcels)) {print(overlapping_parcels$pointid[i])
break}
for (i in 1:nrow(overlapping_parcels)) {
print(overlapping_parcels$pointid[i])
break}
for (i in 1:nrow(overlapping_parcels)) {
df_tc[df_tc$pointid == overlapping_parcels$pointid[i]])
for (i in 1:nrow(overlapping_parcels)) {
df_tc[df_tc$pointid == overlapping_parcels$pointid[i]]
break}
for (i in 1:nrow(overlapping_parcels)) {
df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
break}
for (i in 1:nrow(overlapping_parcels)) {
print(df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ])
break}
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
break}
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
break}
st_intersection(overlapping_parcels[i], circle_geom)
st_intersects(overlapping_parcels[i], circle_geom)
st_intersect(overlapping_parcels[i], circle_geom)
st_clip(overlapping_parcels[i], circle_geom)
st_intersection(overlapping_parcels[i], circle_geom)
overlapping_parcels[1]
overlapping_parcels[i]
overlapping_parcels[i, ]
st_intersection(overlapping_parcels[i], circle_geom).plot()
plot(st_intersection(overlapping_parcels[i], circle_geom))
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i]]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
break
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels$geometry[i], circle_geom)
geometry_list[[i]] <- intersected_geom
break
}
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
geometry_list[[i]] <- intersected_geom
break
}
# Loop through and intersect the parcels with their corresponding circles
geometry_list <- list()
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
geometry_list[[i]] <- intersected_geom
break
}
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
geometry_list[[i]] <- intersected_geom
break
}
geometry_list
st_sfc(geometry_list)
do.call(st_sfc, geometry_list)
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
# 4) Split parcels in overlapping circles
overlapping_parcels <-
buffer_result_2 |>
st_as_sf() |>
group_by(REF_ID) |>
filter(n()>1)
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i], circle_geom)
geometry_list[[i]] <- intersected_geom
}
overlapping_parcels[5]
overlapping_parcels[[5]]
overlapping_parcels[[2]]
overlapping_parcels[5,]
intersected_geom <- st_intersection(overlapping_parcels[i, ], circle_geom)
# Loop through and intersect the parcels with their corresponding circles
geometry_list <- list()
for (i in 1:nrow(overlapping_parcels)) {
circle_geom <- df_tc[df_tc$pointid == overlapping_parcels$pointid[i], ]
intersected_geom <- st_intersection(overlapping_parcels[i, ], circle_geom)
geometry_list[[i]] <- intersected_geom
}
geometry_list
geometry_list[i,] <- intersected_geom
View(geometry_list)
?st_sfc
# Filter the overlapping parcels
overlapping_parcels <-
buffer_result_2 |>
st_as_sf() |>
group_by(REF_ID) |>
filter(n() > 1)
# Perform the intersection for each overlapping parcel using map2 for vectorized operation
overlapping_parcels <- overlapping_parcels %>%
mutate(geometry = map2(geometry, pointid,
~ st_intersection(.x, df_tc[df_tc$pointid == .y, ]$geometry)))
# Perform the intersection for each overlapping parcel using map2 for vectorized operation
overlapping_parcels <- overlapping_parcels %>%
mutate(geometry = map2(geometry, pointid,
~ st_intersection(.x, df_tc[df_tc$pointid == .y, ])))
# Perform the intersection for each overlapping parcel using map2 for vectorized operation
overlapping_parcels <- overlapping_parcels |>
mutate(geometry = map2(geom, pointid,
~ st_intersection(.x, df_tc[df_tc$pointid == .y, ])))
rlang::last_trace()
?map2
library(inborutils)
library(sf)
library(dplyr)
library(purrr)
library(qgisprocess)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
print(getwd())
#---- Functions ----
download_from_zenodo <- function(download_path, zenodo_doi, file_name) {
# Create the full file path
file_path <- file.path(download_path, file_name)
# Check if the file already exists in the download directory
if (file.exists(file_path)) {
print("File already exists at the specified path.")
} else {
# Download the file if it doesn't exist
inborutils::download_zenodo(
doi = zenodo_doi,
path = download_path
)
print('File was downloaded')
}
}
process_telpunten <- function(input_csv, buffer_distance = 300) {
# Step 1: Read the CSV file into a dataframe
df_pts <- read.csv(input_csv)
# Step 2: Create an sf object with 'geometry' column based on the coordinates (assuming x and y coordinates are in 'x_coord' and 'y_coord')
df_pts <- df_pts %>%
st_as_sf(coords = c('x_coord', 'y_coord'), crs = df_pts$crs[1])
# Step 3: Buffer the points by the specified distance (default 300 meters)
df_pts_buffered <- st_buffer(df_pts, dist = buffer_distance)
# Step 4: Write to file
#make if else
# Step 5: Return points
return(df_pts_buffered)
}
# Download telpunten van Zenodo
download_path <- '../data/raw'
zenodo_doi <- '10.5281/zenodo.10890741'  # Replace with the actual Zenodo DOI
file_name <- 'Beaver_territories.csv' #to do: change to 'steekproef_mbag_mas.csv'
download_from_zenodo(download_path, zenodo_doi, file_name)
# Omzetten van de telpunten naar telcirkels(buffer)
input_csv <- "../data/raw/steekproef_mbag_mas.csv"
df_tc <- process_telpunten(input_csv, buffer_distance = 300)
?st_cast
Q_schijf <- 'Q:/Projects/PRJ_MBAG/4a_mas/verzamelaanvraag/processed'
layer_name = 'landbouwgebruikspercelen_cut_bo_2022'
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = paste0("SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM ", layer_name, "LIMIT 500")
)
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = "SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM landbouwgebruikspercelen_cut_bo_2022 LIMIT 1000"
)
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels_subset, #file.path(Q_schijf, kaartlagen[1])
OVERLAY = telcirkels,
OUTPUT = '../data/processed/intersection_test.gpkg'
)
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels., #file.path(Q_schijf, kaartlagen[1])
OVERLAY = telcirkels,
OUTPUT = '../data/processed/intersection_test.gpkg'
)
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels, #file.path(Q_schijf, kaartlagen[1])
OVERLAY = telcirkels,
OUTPUT = '../data/processed/intersection_test.gpkg'
)
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels, #file.path(Q_schijf, kaartlagen[1])
OVERLAY = df_tc,
OUTPUT = '../data/processed/intersection_test.gpkg'
)
Q_schijf <- 'Q:/Projects/PRJ_MBAG/4a_mas/verzamelaanvraag/processed'
Q_schijf_output <- 'Q:/Projects/PRJ_MBAG/4d_bwk/tijdsreeksen'
layer_name = 'landbouwgebruikspercelen_cut_bo_2022'
clip_parcels <- function(layer_name, telcirkels) {
# Read in the fields
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = paste0("SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM ", layer_name, " LIMIT 500")
)
# Weglaten van landbouwinfrastructuur uit parcels (hiervoor willen we geen tijdsreeksen)
parcels_subset <- parcels |>
filter(GWSGRPH_LB != 'Landbouwinfrastructuur')
# QGIS processing
# 1) Clip fields
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels_subset, #file.path(Q_schijf, kaartlagen[1])
OVERLAY = telcirkels
)
# 2) Assign pointid to the parcels
result <- qgis_run_algorithm(
"native:joinattributesbylocation",
INPUT = result$OUTPUT,
JOIN = telcirkels,
PREDICATE = 'intersect',
JOIN_FIELDS = 'pointid',
METHOD = 0, # for every match, create a separate geometry
)
# 3) Buffer (to remove line geometries)
result <- qgis_run_algorithm(
"native:buffer",
INPUT = result$OUTPUT,
DISTANCE = -2
) |>
st_as_sf() |>
filter(!st_is_empty(geom)) #filter empty geometries
buffer_result_2 <- qgis_run_algorithm(
"native:buffer",
INPUT = result,
DISTANCE = 2,
OUTPUT = file.path(Q_schijf_output, paste0(layer_name, '.gpkg'))
)
}
clip_parcels(layer_name = layer_name, telcirkels = df_tc)
View(clip_parcels)
Q_schijf <- 'Q:/Projects/PRJ_MBAG/4a_mas/verzamelaanvraag/processed'
Q_schijf_output <- 'Q:/Projects/PRJ_MBAG/4d_bwk/tijdsreeksen'
layer_name = 'landbouwgebruikspercelen_cut_bo_2022'
clip_parcels <- function(layer_name, telcirkels) {
# Read in the fields
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = paste0("SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM ", layer_name, " LIMIT 500")
)
# Weglaten van landbouwinfrastructuur uit parcels (hiervoor willen we geen tijdsreeksen)
parcels_subset <- parcels |>
filter(GWSGRPH_LB != 'Landbouwinfrastructuur')
# QGIS processing
# 1) Intersection fields
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels_subset, #file.path(Q_schijf, kaartlagen[1])
OVERLAY = telcirkels
)
# 1.1) Perform intersection to ensure parcels are split by circle boundaries
split_parcels <- st_intersection(st_as_sf(result$OUTPUT), telcirkels)
# 2) Assign pointid to the parcels
result <- qgis_run_algorithm(
"native:joinattributesbylocation",
INPUT = split_parcels,
JOIN = telcirkels,
PREDICATE = 'intersect',
JOIN_FIELDS = 'pointid',
METHOD = 0, # for every match, create a separate geometry
)
# 3) Buffer (to remove line geometries)
result <- qgis_run_algorithm(
"native:buffer",
INPUT = result$OUTPUT,
DISTANCE = -2
) |>
st_as_sf() |>
filter(!st_is_empty(geom)) #filter empty geometries
buffer_result_2 <- qgis_run_algorithm(
"native:buffer",
INPUT = result,
DISTANCE = 2,
OUTPUT = file.path(Q_schijf_output, paste0(layer_name, 'clip', '.gpkg'))
)
}
clip_parcels(layer_name = layer_name, telcirkels = df_tc)
qgis_show_help('native:intersection')
library(inborutils)
library(sf)
library(dplyr)
library(qgisprocess)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
print(getwd())
#---- Functions ----
download_from_zenodo <- function(download_path, zenodo_doi, file_name) {
# Create the full file path
file_path <- file.path(download_path, file_name)
# Check if the file already exists in the download directory
if (file.exists(file_path)) {
print("File already exists at the specified path.")
} else {
# Download the file if it doesn't exist
inborutils::download_zenodo(
doi = zenodo_doi,
path = download_path
)
print('File was downloaded')
}
}
process_telpunten <- function(input_csv, buffer_distance = 300) {
# Step 1: Read the CSV file into a dataframe
df_pts <- read.csv(input_csv)
# Step 2: Create an sf object with 'geometry' column based on the coordinates (assuming x and y coordinates are in 'x_coord' and 'y_coord')
df_pts <- df_pts %>%
st_as_sf(coords = c('x_coord', 'y_coord'), crs = df_pts$crs[1])
# Step 3: Buffer the points by the specified distance (default 300 meters)
df_pts_buffered <- st_buffer(df_pts, dist = buffer_distance)
# Step 4: Write to file
#make if else
# Step 5: Return points
return(df_pts_buffered)
}
# Download telpunten van Zenodo
download_path <- '../data/raw'
zenodo_doi <- '10.5281/zenodo.10890741'  # Replace with the actual Zenodo DOI
file_name <- 'Beaver_territories.csv' #to do: change to 'steekproef_mbag_mas.csv'
download_from_zenodo(download_path, zenodo_doi, file_name)
# Omzetten van de telpunten naar telcirkels(buffer)
input_csv <- "../data/raw/steekproef_mbag_mas.csv"
df_tc <- process_telpunten(input_csv, buffer_distance = 300)
Q_schijf <- 'Q:/Projects/PRJ_MBAG/4a_mas/verzamelaanvraag/processed'
Q_schijf_output <- 'Q:/Projects/PRJ_MBAG/4d_bwk/tijdsreeksen'
layer_name = 'landbouwgebruikspercelen_cut_bo_2022'
library(inborutils)
library(sf)
library(dplyr)
library(qgisprocess)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
print(getwd())
#---- Functions ----
download_from_zenodo <- function(download_path, zenodo_doi, file_name) {
# Create the full file path
file_path <- file.path(download_path, file_name)
# Check if the file already exists in the download directory
if (file.exists(file_path)) {
print("File already exists at the specified path.")
} else {
# Download the file if it doesn't exist
inborutils::download_zenodo(
doi = zenodo_doi,
path = download_path
)
print('File was downloaded')
}
}
process_telpunten <- function(input_csv, buffer_distance = 300) {
# Step 1: Read the CSV file into a dataframe
df_pts <- read.csv(input_csv)
# Step 2: Create an sf object with 'geometry' column based on the coordinates (assuming x and y coordinates are in 'x_coord' and 'y_coord')
df_pts <- df_pts %>%
st_as_sf(coords = c('x_coord', 'y_coord'), crs = df_pts$crs[1])
# Step 3: Buffer the points by the specified distance (default 300 meters)
df_pts_buffered <- st_buffer(df_pts, dist = buffer_distance)
# Step 4: Write to file
#make if else
# Step 5: Return points
return(df_pts_buffered)
}
# Download telpunten van Zenodo
download_path <- '../data/raw'
zenodo_doi <- '10.5281/zenodo.10890741'  # Replace with the actual Zenodo DOI
file_name <- 'Beaver_territories.csv' #to do: change to 'steekproef_mbag_mas.csv'
download_from_zenodo(download_path, zenodo_doi, file_name)
# Omzetten van de telpunten naar telcirkels(buffer)
input_csv <- "../data/raw/steekproef_mbag_mas.csv"
df_tc <- process_telpunten(input_csv, buffer_distance = 300)
Q_schijf <- 'Q:/Projects/PRJ_MBAG/4a_mas/verzamelaanvraag/processed'
Q_schijf_output <- 'Q:/Projects/PRJ_MBAG/4d_bwk/tijdsreeksen'
layer_name = 'landbouwgebruikspercelen_cut_bo_2022'
clip_parcels <- function(layer_name, telcirkels) {
# Read in the fields
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = paste0("SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM ", layer_name, " LIMIT 500")
)
# Weglaten van landbouwinfrastructuur uit parcels (hiervoor willen we geen tijdsreeksen)
parcels_subset <- parcels |>
filter(GWSGRPH_LB != 'Landbouwinfrastructuur')
# QGIS processing
# 1) Intersection fields
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels_subset,
OVERLAY = telcirkels
)
# 1.1) Perform intersection to ensure parcels are split by circle boundaries
#split_parcels <- st_intersection(st_as_sf(result$OUTPUT), telcirkels)
# 2) Assign pointid to the parcels
result <- qgis_run_algorithm(
"native:joinattributesbylocation",
INPUT = result$OUTPUT,
JOIN = telcirkels,
PREDICATE = 'intersect',
JOIN_FIELDS = 'pointid',
METHOD = 0, # for every match, create a separate geometry
)
# 3) Buffer (to remove line geometries)
result <- qgis_run_algorithm(
"native:buffer",
INPUT = result$OUTPUT,
DISTANCE = -2
) |>
st_as_sf() |>
filter(!st_is_empty(geom)) #filter empty geometries
buffer_result_2 <- qgis_run_algorithm(
"native:buffer",
INPUT = result,
DISTANCE = 2,
OUTPUT = file.path(Q_schijf_output, paste0(layer_name, '_clip', '.gpkg'))
)
}
df_tc
clip_parcels <- function(layer_name, telcirkels) {
# Read in the fields
parcels <- st_read(
file.path(Q_schijf, paste0(layer_name, '.gpkg')),
layer = layer_name,
query = paste0("SELECT REF_ID, GRAF_OPP, GWSGRPH_LB, LANDBSTR, jaar, geom FROM ", layer_name, " LIMIT 500")
)
# Weglaten van landbouwinfrastructuur uit parcels (hiervoor willen we geen tijdsreeksen)
parcels_subset <- parcels |>
filter(GWSGRPH_LB != 'Landbouwinfrastructuur')
# QGIS processing
# 1) Intersection fields
result <- qgis_run_algorithm(
algorithm = 'native:intersection',
INPUT = parcels_subset,
OVERLAY = telcirkels
)
# 1.1) Perform intersection to ensure parcels are split by circle boundaries
#split_parcels <- st_intersection(st_as_sf(result$OUTPUT), telcirkels)
# 2) Assign pointid to the parcels
result <- qgis_run_algorithm(
"native:joinattributesbylocation",
INPUT = result$OUTPUT,
JOIN = telcirkels,
PREDICATE = 'intersect',
JOIN_FIELDS = 'pointid',
METHOD = 0, # for every match, create a separate geometry
)
# 3) Buffer (to remove line geometries)
result <- qgis_run_algorithm(
"native:buffer",
INPUT = result$OUTPUT,
DISTANCE = -2
) |>
st_as_sf() |>
filter(!st_is_empty(geom)) #filter empty geometries
buffer_result <- qgis_run_algorithm(
"native:buffer",
INPUT = result,
DISTANCE = 2,
OUTPUT = file.path(Q_schijf_output, paste0(layer_name, '_clip', '.gpkg'))
)
}
clip_parcels(layer_name = layer_name, telcirkels = df_tc)
